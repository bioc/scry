---
title: "Benchmarking scry methods with DelayedArray backends"
author: "Stephanie Hicks"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  BiocStyle::html_document:
    toc: false
vignette: >
  %\VignetteEngine{knitr::knitr}
  %\VignetteIndexEntry{Benchmarking scry methods with DelayedArray backends}
  %\usepackage[UTF-8]{inputenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
suppressPackageStartupMessages(library(SingleCellExperiment))
library(DelayedArray)
library(BiocSingular)
require(scry)
```

# Overview

For large datasets, it may be advantageous to keep the original data in a on-disk HDF5 file and avoid loading the full data in memory.

This is a vignette to benchmark how `scry` performs with in-memory data vs matrix-like objects from [`DelayedArray`](https://bioconductor.org/packages/DelayedArray) Bioconductor package (`DelayedMatrix`, `HDF5Matrix`). 

For now, we are focused on benchmarking the `scry::nullResiduals` function with a Poisson model and using deviance residuals. We will expand this to other options later. 

To get started, we will work with the `TENxBrainData` ExperimentHub data package that contains 1.3 million brain cell scRNA-seq data from 10X Genomics. 

```{r}
library(TENxBrainData)
tenx <- TENxBrainData()

tenx <- tenx[,1:100] # start with a small subset for testing while building benchmark code
```

# Benchmark

First let's realize the counts matrix in the `tenx` SCE. 
```{r}
tenx_realized <- tenx
assay(tenx_realized, "counts") <- as.matrix(assay(tenx, "counts"))
assay(tenx_realized, "counts")[1:5, 1:5]
dim(tenx_realized)
```

Next, confirm that the sizes are very different: 
```{r}
pryr::object_size(tenx) # 4.44 MB
pryr::object_size(tenx_realized) # 15.6 MB
```

Yep, they are different. OK let's apply the various options: 

Here, we run the in-memory, vectorized `nullResiduals()` function: 

```{r}
time_start <- proc.time()
tenx_realized <- nullResiduals(tenx_realized, assay="counts", type="deviance")
time_end <- proc.time()
time_inmem_vec <- time_end - time_start
time_inmem_vec
# > time_inmem_vec
#    user  system elapsed
#   0.874   0.216   1.094
```

Next, we try the `DelayedArray`, vectorized `nullResiduals()` function: 
```{r}
time_start <- proc.time()
tenx_vec <- nullResiduals(tenx, assay="counts", type="deviance")
pcs.out <- runPCA(assay(tenx_vec, "binomial_deviance_residuals"), 
                  rank=10, BSPARAM=ExactParam())
time_end <- proc.time()
time_da_vec <- time_end - time_start

str(pcs.out)
```

Next, we try the `DelayedArray`, the `nullResiduals()` function that uses 
`BiocSingular::LowRankMatrix`: 

**note** once Kelly updates the `nullResiduals()` function, the `.null_poisson_deviance_residuals_delayed()` function will not exist and the code below will need to be updated. 

```{r}
time_start <- proc.time()
tmp <- .null_poisson_deviance_residuals_delayed(assay(tenx, "counts"))
pcs.out <- runPCA(tmp, rank=10, BSPARAM=ExactParam())
time_end <- proc.time()
time_da_lrm <- time_end - time_start

str(pcs.out)
```

Compare the times 
```{r}
time_inmem_vec
time_da_vec
time_da_lrm
```

